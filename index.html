<!DOCTYPE html>
<html>
    <head>
        <title>WebSerial Prototype</title>
        <style>
            .log {
                white-space: pre-wrap;
                width: 30rem;
                height: 10rem;
                overflow-y: auto;
            }
            .aesthetic-btn {
                background-color: transparent;
                border: 5px outset #AAAAAA;
                border-radius: 1rem;
                padding: 2rem 6rem;
                font-size: 2rem;
                color: transparent;
                text-shadow: 0 0 #373737;
            }
            .aesthetic-btn:active {
                border-style: inset;
                background-color: #67676737;
                text-shadow: 1px 1px black;
            }
        </style>
        <script src="https://www.desmos.com/api/v1.11/calculator.js?apiKey=70d530c75bc2432bbfc6dce64cf7fb0e"></script>
    </head>
    <body>
        <h1>The Hygroscopinator</h1>
        <h2>~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</h2>
        <button class="aesthetic-btn" id="launch">Launch</button>
        <div class="sensor" id="humidity">
            <h3>Soil Humidity</h3>
            <div class="log">[soil humidity input log]</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <div class="sensor" id="luminosity">
            <h3>Light</h3>
            <div class="log">[light level input log]</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <div class="sensor" id="protonicity">
            <h3>pH</h3>
            <div class="log">[pH input log]</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <h2>~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</h2>
        <script type="module">
            if (!("serial" in navigator)) {
                alert("what cooked ahh browser are we on");
                throw "ðŸŸ";
            }

            const calcElems = {
                hp: document.getElementsByClassName("calculator")[0],
                light: document.getElementsByClassName("calculator")[1],
                ph: document.getElementsByClassName("calculator")[2]
            };
            const calc = {
                hp: Desmos.GraphingCalculator(calcElems.hp, {expressions: false, settingsMenu: false, lockViewport: true}),
                light: Desmos.GraphingCalculator(calcElems.light, {expressions: false, settingsMenu: false, lockViewport: true}),
                ph: Desmos.GraphingCalculator(calcElems.ph, {expressions: false, settingsMenu: false, lockViewport: true}),
            };

            const allData = {
                hp: {points: [], color: Desmos.Colors.BLUE},
                light: {points: [], color: Desmos.Colors.ORANGE},
                ph: {points: [], color: Desmos.Colors.PURPLE}
            };
            
            [...document.getElementsByClassName("dcg-graphpaper-branding")].forEach(j => j.remove());

            const startAllTarget = document.getElementById("launch");
            startAllTarget.addEventListener("click", startAll);
            
            async function startAll() {
                try {
                    //navigator.usb.getDevices().then((devices) => {
                    //devices.forEach((device) => {
                    //console.log(device.productName); // "Arduino Uno"
                    //console.log(device.manufacturerName); // "Arduino LLC"
                    //});
                    //});
                    const mfkPort = await navigator.serial.requestPort();
                    
                    await port.open({baudRate: 9600});

                    window.mfkReader = mfkPort.readable.getReader();

                    setInterval(readDevice, 167);
                }
                catch (e) {
                    console.error(`Connection terminated. ${e}`);
                    setInterval(inSilico, 1670);
                }
                finally {
                    startAllTarget.remove();
                }
            }

            async function readDevice() {
                while (port.readable) {
                    const {value, finish} = await window.mfkReader.read();
                    if (finish) {
                        window.mfkReader.releaseLock();
                        break;
                    }

                    if (value) {
                        // for every byte
                        for (let i = 0; i < value.length; i++) {
                            // convert to ascii
                            const char = String.fromCharCode(value[i]);
        
                            // delimiters: \n, !
                            if (char === '\n' || char === '!') {
                                // must have a colon
                                if (window.mfkBuffer.includes(':')) {
                                    onRX(window.mfkBuffer);
                                }
                                
                                window.mfkBuffer = "";
                                
                            } else {
                                window.mfkBuffer += char;
                            }
                        }
                    }
                }
            }

            function inSilico() {
                onRX(`hp: ${Math.random() * 10 + 50}`);
                onRX(`light: ${Math.random() ** 2 * 0.3}`);
                onRX(`ph: ${Math.random() ** 2 * 1.2 + 6.3}`);
            }

            var startTime = "unset";

            function onRX(data) {
                console.log(data);
                const [sensor, value] = data.split(': ');
                sensorChange(sensor, value);
            }
            
            function sensorChange(sensor, data) {
                const div = document.getElementById(sensor);
                const thisCalc = calc[sensor];
                const sensorData = allData[sensor];
                const log = calcElems[sensor].previousElementSibling;

                if (!thisCalc || !sensorData || !log) {
                    console.error(`sensor DNE: ${sensor}`);
                }
                
                log.append(`\n${data}`);

                if (startTime === "unset") startTime = Date.now()

                const timeElapsed = (Date.now() - startTime) / 1000;

                sensorData.points.push([timeElapsed, data]);

                thisCalc.setExpression({
                    id: "sensor_data",
                    type: "table",
                    columns: [
                        {
                            latex: "x_1",
                            values: sensorData.points.map(p => p[0])
                        },
                        {
                            latex: "y_1",
                            values: sensorData.points.map(p => p[1]),
                            color: sensorData.color,
                            lines: true,
                            points: true
                        }
                    ]
                });

                rescaleView(thisCalc, sensorData.points, sensor)
            }

            function rescaleView(calculatorInstance, points, sensorName) {
                if (points.length === 0) return;
                
                // Extract separate X and Y arrays
                const xValues = points.map(p => p[0]);
                const yValues = points.map(p => p[1]);
                
                // Find mins and maxs
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues);
                const minY = Math.min(...yValues);
                const maxY = Math.max(...yValues);
                
                // Add padding (margin) so points aren't exactly on the edge
                // Defaulting to 1 if there's no range (single point)
                const paddingX = (maxX - minX) * 0.1 || 1; 
                const paddingY = (maxY - minY) * 0.1 || 1;

                if (sensorName === "ph") {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: -1,
                        top: 15
                    });
                }
                else if (sensorName === "hp") {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: -10,
                        top: 110
                    });
                }
                else if (sensorName === "light") {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: -0.1,
                        top: 1.1
                    });
                }
                else {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: minY - paddingY,
                        top: maxY + paddingY
                    });
                }
            }
            
            window.exe = e => eval(e);
        </script>
    </body>
</html>
