<!DOCTYPE html>
<html>
    <head>
        <title>WebSerial Prototype</title>
        <!-- <meta http-equiv="Content-Security-Policy" content="script-src 'https://www.desmos.com' 'unsafe-eval' 'unsafe-inline';"> -->
        <style>
        </style>
        <script src="https://www.desmos.com/api/v1.11/calculator.js?apiKey=70d530c75bc2432bbfc6dce64cf7fb0e"></script>
    </head>
    <body>
        <h1>The Hygroscopinator</h1>
        <h2>~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</h2>
        <div class="sensor" id="humidity">
            <h3>Soil Humidity</h3>
            <div class="log">(H%)</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <div class="sensor" id="luminosity">
            <h3>Light</h3>
            <div class="log">(light)</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <div class="sensor" id="protonicity">
            <h3>pH</h3>
            <div class="log">(pH)</div>
            <div class="calculator" style="width: 600px; height: 400px;"></div>
        </div>
        <h2>~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</h2>
        <script type="module">
            if (!("serial" in navigator)) {
                alert("what cooked ahh browser are we on");
                throw "ðŸŸ";
            }

            const calcElems = {
                hp: document.getElementsByClassName("calculator")[0],
                light: document.getElementsByClassName("calculator")[1],
                ph: document.getElementsByClassName("calculator")[2]
            };
            const calc = {
                hp: Desmos.GraphingCalculator(calcElems.hp, {expressions: false, settingsMenu: false, lockViewport: true}),
                light: Desmos.GraphingCalculator(calcElems.light, {expressions: false, settingsMenu: false, lockViewport: true}),
                ph: Desmos.GraphingCalculator(calcElems.ph, {expressions: false, settingsMenu: false, lockViewport: true}),
            };

            const allData = {
                hp: {points: [], color: Desmos.Colors.BLUE},
                light: {points: [], color: Desmos.Colors.ORANGE},
                ph: {points: [], color: Desmos.Colors.PURPLE}
            };
            
            [...document.getElementsByClassName("dcg-graphpaper-branding")].forEach(j => j.remove());

            const startAllTarget = window;
            startAllTarget.addEventListener("dblclick", startAll);
            
            async function startAll() {
                let port;
                let w;
                
                try {
                    //navigator.usb.getDevices().then((devices) => {
                    //devices.forEach((device) => {
                    //console.log(device.productName); // "Arduino Uno"
                    //console.log(device.manufacturerName); // "Arduino LLC"
                    //});
                    //});
                    port = await navigator.serial.requestPort();
                    
                    await port.open({baudRate: 9600});
                }
                catch (e) {
                    alert(`Connection terminated. ${e}`);
                }
                finally {
                    startAllTarget.removeEventListener("keydown", startAll);
                }
            }

            var startTime = "unset";

            function onRX(data) {
                const [sensor, value] = data.split(': ');
                sensorChange(sensor, value);
            }
            
            function sensorChange(sensor, data) {
                const div = document.getElementById(sensor);
                const thisCalc = calc[sensor];
                const sensorData = allData[sensor];
                const log = calcElems[sensor].previousElementSibling;

                if (!thisCalc || !sensorData || !log) {
                    console.error(`sensor DNE: ${sensor}`);
                }
                
                log.append(`\n${data}`);

                if (startTime === "unset") startTime = Date.now()

                const timeElapsed = (Date.now() - startTime) / 1000;

                sensorData.points.push([timeElapsed, data]);

                thisCalc.setExpression({
                    id: "sensor_data",
                    type: "table",
                    columns: [
                        {
                            latex: "x_1",
                            values: sensorData.points.map(p => p[0])
                        },
                        {
                            latex: "y_1",
                            values: sensorData.points.map(p => p[1]),
                            color: sensorData.color,
                            lines: true,
                            points: true
                        }
                    ]
                });

                rescaleView(thisCalc, sensorData.points, sensor)
            }

            function rescaleView(calculatorInstance, points, sensorName) {
                if (points.length === 0) return;
                
                // Extract separate X and Y arrays
                const xValues = points.map(p => p[0]);
                const yValues = points.map(p => p[1]);
                
                // Find mins and maxs
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues);
                const minY = Math.min(...yValues);
                const maxY = Math.max(...yValues);
                
                // Add padding (margin) so points aren't exactly on the edge
                // Defaulting to 1 if there's no range (single point)
                const paddingX = (maxX - minX) * 0.1 || 1; 
                const paddingY = (maxY - minY) * 0.1 || 1;

                if (sensorName === "ph") {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: -1,
                        top: 15
                    });
                }
                else if (sensorName === "hp") {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: -10,
                        top: 110
                    });
                }
                else {
                    calculatorInstance.setMathBounds({
                        left: minX - paddingX,
                        right: maxX + paddingX,
                        bottom: minY - paddingY,
                        top: maxY + paddingY
                    });
                }
            }
            
            window.exe = e => eval(e);
        </script>
    </body>
</html>
